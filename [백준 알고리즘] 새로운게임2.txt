//새로운게임2
#include <iostream>
#include <vector>
#include <cstdio>

using namespace std;

typedef struct cell{
    int r,c;
    int dir;
    int rootInd;
}Cell;

int rdir[5] = {0,0,0,-1,1};
int cdir[5] = {0,1,-1,0,0};

int n,k;
int arr[101][101];

vector <Cell> root;
vector <Cell> center[30][30];

int changeDir(int dir){
    if(dir ==1){return 2;}
    if(dir ==2){return 1;}
    if(dir ==3){return 4;}
    if(dir ==4){return 3;}
    return 3;
}
bool canGo(int r, int c){
    if(r<0 || r>=n || c<0 || c>=n){
        return false;
    }
    else if(arr[r][c] == 2){
        return false;
    }
    else{
        return true;
    }
}
int main(){
    
    scanf("%d %d", &n,&k);
    
    for(int i =0; i<n; i++){
        for(int j =0; j<n; j++){
            scanf("%d", &arr[i][j]);
        }
    }
    
    for(int i =0; i<k; i++){
        Cell temp;
        scanf("%d %d %d", &temp.r, &temp.c, &temp.dir);
        temp.r-=1; temp.c -=1;
        temp.rootInd = i;
        root.push_back(temp);
        center[temp.r][temp.c].push_back(temp);
    }
    
    for(int turn =1; turn<=1000; turn++){
        for(int ind =0; ind<root.size(); ind++){
            for(int i =0; i<center[root[ind].r][root[ind].c].size(); i++){
                if(center[root[ind].r][root[ind].c][i].rootInd == ind){
                    int mainR = root[ind].r;
                    int mainC = root[ind].c;
                    int mainDir = root[ind].dir;
                    int count =0;
                    
                    if(!canGo(mainR+rdir[mainDir], mainC+cdir[mainDir])){
                        //방향 전환
                        mainDir = changeDir(mainDir);
                        root[ind].dir = mainDir;
                        center[root[ind].r][root[ind].c][i] = root[ind];
                        
                        if(canGo(mainR+rdir[mainDir], mainC+cdir[mainDir])){
                            //백업하기
                            vector <Cell> backup;
                            for(int j = i; j<center[mainR][mainC].size(); j++){
                                center[mainR][mainC][j].r = mainR+rdir[mainDir];
                                center[mainR][mainC][j].c = mainC+cdir[mainDir];
                                backup.push_back(center[mainR][mainC][j]);
                                count++;
                            }
                            //기본 root 부분들 모두 바꾸기
                            for(int j = 0; j<count; j++){
                                center[mainR][mainC].pop_back();
                            }
                            
                            //다음 장소에 삽입하기
                            if(arr[mainR+rdir[mainDir]][mainC+cdir[mainDir]] ==1){ //빨간색일 경우
                                for(int j=backup.size()-1; j>=0; j--){
                                    root[backup[j].rootInd].r = backup[j].r;
                                    root[backup[j].rootInd].c = backup[j].c;
                                    center[backup[j].r][backup[j].c].push_back(backup[j]);
                                }
                            }
                            else{   //흰색일 경우
                                for(int j=0; j<backup.size(); j++){
                                    root[backup[j].rootInd].r = backup[j].r;
                                    root[backup[j].rootInd].c = backup[j].c;
                                    center[backup[j].r][backup[j].c].push_back(backup[j]);
                                }
                            }
                            
                            //메인이 되는 root의 dir 값은 이미 바꿔버림
                        }
                    }
                    else if(arr[mainR+rdir[mainDir]][mainC+cdir[mainDir]]==1){
                        vector <Cell> backup;
                        for(int j = i; j<center[mainR][mainC].size(); j++){
                            center[mainR][mainC][j].r = mainR+rdir[mainDir];
                            center[mainR][mainC][j].c = mainC+cdir[mainDir];
                            backup.push_back(center[mainR][mainC][j]);
                            count++;
                        }
                        //기본 root 부분들 모두 바꾸기
                        for(int j = 0; j<count; j++){
                            center[mainR][mainC].pop_back();
                        }
                        //반대로 삽입하기
                        for(int j=backup.size()-1; j>=0; j--){
                            root[backup[j].rootInd].r = backup[j].r;
                            root[backup[j].rootInd].c = backup[j].c;
                            center[backup[j].r][backup[j].c].push_back(backup[j]);
                        }
                    }
                    else{
                        vector <Cell> backup;
                        for(int j = i; j<center[mainR][mainC].size(); j++){
                            center[mainR][mainC][j].r = mainR+rdir[mainDir];
                            center[mainR][mainC][j].c = mainC+cdir[mainDir];
                            backup.push_back(center[mainR][mainC][j]);
                            count++;
                        }
                        //기본 root 부분들 모두 바꾸기
                        for(int j = 0; j<count; j++){
                            center[mainR][mainC].pop_back();
                        }
                        //다음 장소에 삽입하기
                        for(int j=0; j<backup.size(); j++){
                            root[backup[j].rootInd].r = backup[j].r;
                            root[backup[j].rootInd].c = backup[j].c;
                            center[backup[j].r][backup[j].c].push_back(backup[j]);
                        }
                        //go
                    }
                    break;
                }
            }
            for(int i =0; i<root.size(); i++){
                if(center[root[i].r][root[i].c].size() >=4){
                    printf("%d", turn);
                    return 0;
                }
            }
            
        }
 
        
        for(int ind =0; ind<root.size(); ind++){
            if(center[root[ind].r][root[ind].c].size() >=4){
                printf("%d", turn);
                return 0;
            }
        }
    }
    printf("-1");
    return 0;
}
